/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export interface OSSeaport14Interface extends utils.Interface {
  contractName: "OSSeaport14";
  functions: {
    "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])": FunctionFragment;
    "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)": FunctionFragment;
    "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],tuple[][],tuple[][],bytes32,address,uint256)": FunctionFragment;
    "fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],tuple[][],tuple[][],bytes32,uint256)": FunctionFragment;
    "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": FunctionFragment;
    "fulfillBasicOrder_efficient_6GL6yc((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": FunctionFragment;
    "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": FunctionFragment;
    "getContractOffererNonce(address)": FunctionFragment;
    "getCounter(address)": FunctionFragment;
    "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": FunctionFragment;
    "getOrderStatus(bytes32)": FunctionFragment;
    "incrementCounter()": FunctionFragment;
    "information()": FunctionFragment;
    "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[],address)": FunctionFragment;
    "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": FunctionFragment;
    "name()": FunctionFragment;
    "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "cancel",
    values: [
      {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAdvancedOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      BytesLike,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAvailableAdvancedOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      BytesLike,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillAvailableOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      { orderIndex: BigNumberish; itemIndex: BigNumberish }[][],
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillBasicOrder",
    values: [
      {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillBasicOrder_efficient_6GL6yc",
    values: [
      {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillOrder",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractOffererNonce",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "getCounter", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getOrderHash",
    values: [
      {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderStatus",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "information",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "matchAdvancedOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "matchOrders",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "validate",
    values: [
      {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[]
    ]
  ): string;

  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAdvancedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAvailableAdvancedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillAvailableOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillBasicOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillBasicOrder_efficient_6GL6yc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractOffererNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCounter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOrderStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "information",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "matchAdvancedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "matchOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "validate", data: BytesLike): Result;

  events: {
    "CounterIncremented(uint256,address)": EventFragment;
    "OrderCancelled(bytes32,address,address)": EventFragment;
    "OrderFulfilled(bytes32,address,address,address,tuple[],tuple[])": EventFragment;
    "OrderValidated(bytes32,tuple)": EventFragment;
    "OrdersMatched(bytes32[])": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CounterIncremented"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderFulfilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderValidated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrdersMatched"): EventFragment;
}

export type CounterIncrementedEvent = TypedEvent<
  [BigNumber, string],
  { newCounter: BigNumber; offerer: string }
>;

export type CounterIncrementedEventFilter =
  TypedEventFilter<CounterIncrementedEvent>;

export type OrderCancelledEvent = TypedEvent<
  [string, string, string],
  { orderHash: string; offerer: string; zone: string }
>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export type OrderFulfilledEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    ([number, string, BigNumber, BigNumber] & {
      itemType: number;
      token: string;
      identifier: BigNumber;
      amount: BigNumber;
    })[],
    ([number, string, BigNumber, BigNumber, string] & {
      itemType: number;
      token: string;
      identifier: BigNumber;
      amount: BigNumber;
      recipient: string;
    })[]
  ],
  {
    orderHash: string;
    offerer: string;
    zone: string;
    recipient: string;
    offer: ([number, string, BigNumber, BigNumber] & {
      itemType: number;
      token: string;
      identifier: BigNumber;
      amount: BigNumber;
    })[];
    consideration: ([number, string, BigNumber, BigNumber, string] & {
      itemType: number;
      token: string;
      identifier: BigNumber;
      amount: BigNumber;
      recipient: string;
    })[];
  }
>;

export type OrderFulfilledEventFilter = TypedEventFilter<OrderFulfilledEvent>;

export type OrderValidatedEvent = TypedEvent<
  [
    string,
    [
      string,
      string,
      ([number, string, BigNumber, BigNumber, BigNumber] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
      })[],
      ([number, string, BigNumber, BigNumber, BigNumber, string] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
        recipient: string;
      })[],
      number,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      string,
      BigNumber
    ] & {
      offerer: string;
      zone: string;
      offer: ([number, string, BigNumber, BigNumber, BigNumber] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
      })[];
      consideration: ([
        number,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
        recipient: string;
      })[];
      orderType: number;
      startTime: BigNumber;
      endTime: BigNumber;
      zoneHash: string;
      salt: BigNumber;
      conduitKey: string;
      totalOriginalConsiderationItems: BigNumber;
    }
  ],
  {
    orderHash: string;
    orderParameters: [
      string,
      string,
      ([number, string, BigNumber, BigNumber, BigNumber] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
      })[],
      ([number, string, BigNumber, BigNumber, BigNumber, string] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
        recipient: string;
      })[],
      number,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      string,
      BigNumber
    ] & {
      offerer: string;
      zone: string;
      offer: ([number, string, BigNumber, BigNumber, BigNumber] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
      })[];
      consideration: ([
        number,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ] & {
        itemType: number;
        token: string;
        identifierOrCriteria: BigNumber;
        startAmount: BigNumber;
        endAmount: BigNumber;
        recipient: string;
      })[];
      orderType: number;
      startTime: BigNumber;
      endTime: BigNumber;
      zoneHash: string;
      salt: BigNumber;
      conduitKey: string;
      totalOriginalConsiderationItems: BigNumber;
    };
  }
>;

export type OrderValidatedEventFilter = TypedEventFilter<OrderValidatedEvent>;

export type OrdersMatchedEvent = TypedEvent<
  [string[]],
  { orderHashes: string[] }
>;

export type OrdersMatchedEventFilter = TypedEventFilter<OrdersMatchedEvent>;

export interface OSSeaport14 extends BaseContract {
  contractName: "OSSeaport14";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OSSeaport14Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    getCounter(
      offerer: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { counter: BigNumber }>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber, BigNumber] & {
        isValidated: boolean;
        isCancelled: boolean;
        totalFilled: BigNumber;
        totalSize: BigNumber;
      }
    >;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    information(
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        version: string;
        domainSeparator: string;
        conduitController: string;
      }
    >;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    name(
      overrides?: CallOverrides
    ): Promise<[string] & { contractName: string }>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  cancel(
    orders: {
      offerer: string;
      zone: string;
      offer: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
      }[];
      consideration: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
        recipient: string;
      }[];
      orderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      conduitKey: BytesLike;
      counter: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAdvancedOrder(
    advancedOrder: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    },
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    fulfillerConduitKey: BytesLike,
    recipient: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAvailableAdvancedOrders(
    advancedOrders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    }[],
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    offerFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    considerationFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    fulfillerConduitKey: BytesLike,
    recipient: string,
    maximumFulfilled: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillAvailableOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    offerFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    considerationFulfillments: {
      orderIndex: BigNumberish;
      itemIndex: BigNumberish;
    }[][],
    fulfillerConduitKey: BytesLike,
    maximumFulfilled: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillBasicOrder(
    parameters: {
      considerationToken: string;
      considerationIdentifier: BigNumberish;
      considerationAmount: BigNumberish;
      offerer: string;
      zone: string;
      offerToken: string;
      offerIdentifier: BigNumberish;
      offerAmount: BigNumberish;
      basicOrderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      offererConduitKey: BytesLike;
      fulfillerConduitKey: BytesLike;
      totalOriginalAdditionalRecipients: BigNumberish;
      additionalRecipients: { amount: BigNumberish; recipient: string }[];
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillBasicOrder_efficient_6GL6yc(
    parameters: {
      considerationToken: string;
      considerationIdentifier: BigNumberish;
      considerationAmount: BigNumberish;
      offerer: string;
      zone: string;
      offerToken: string;
      offerIdentifier: BigNumberish;
      offerAmount: BigNumberish;
      basicOrderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      offererConduitKey: BytesLike;
      fulfillerConduitKey: BytesLike;
      totalOriginalAdditionalRecipients: BigNumberish;
      additionalRecipients: { amount: BigNumberish; recipient: string }[];
      signature: BytesLike;
    },
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillOrder(
    order: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    },
    fulfillerConduitKey: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getContractOffererNonce(
    contractOfferer: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

  getOrderHash(
    order: {
      offerer: string;
      zone: string;
      offer: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
      }[];
      consideration: {
        itemType: BigNumberish;
        token: string;
        identifierOrCriteria: BigNumberish;
        startAmount: BigNumberish;
        endAmount: BigNumberish;
        recipient: string;
      }[];
      orderType: BigNumberish;
      startTime: BigNumberish;
      endTime: BigNumberish;
      zoneHash: BytesLike;
      salt: BigNumberish;
      conduitKey: BytesLike;
      counter: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getOrderStatus(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean, BigNumber, BigNumber] & {
      isValidated: boolean;
      isCancelled: boolean;
      totalFilled: BigNumber;
      totalSize: BigNumber;
    }
  >;

  incrementCounter(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  information(
    overrides?: CallOverrides
  ): Promise<
    [string, string, string] & {
      version: string;
      domainSeparator: string;
      conduitController: string;
    }
  >;

  matchAdvancedOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      numerator: BigNumberish;
      denominator: BigNumberish;
      signature: BytesLike;
      extraData: BytesLike;
    }[],
    criteriaResolvers: {
      orderIndex: BigNumberish;
      side: BigNumberish;
      index: BigNumberish;
      identifier: BigNumberish;
      criteriaProof: BytesLike[];
    }[],
    fulfillments: {
      offerComponents: { orderIndex: BigNumberish; itemIndex: BigNumberish }[];
      considerationComponents: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[];
    }[],
    recipient: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  matchOrders(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    fulfillments: {
      offerComponents: { orderIndex: BigNumberish; itemIndex: BigNumberish }[];
      considerationComponents: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[];
    }[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  validate(
    orders: {
      parameters: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        totalOriginalConsiderationItems: BigNumberish;
      };
      signature: BytesLike;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean[],
        ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[]
      ] & {
        availableOrders: boolean[];
        executions: ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[];
      }
    >;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean[],
        ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[]
      ] & {
        availableOrders: boolean[];
        executions: ([
          [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          },
          string,
          string
        ] & {
          item: [number, string, BigNumber, BigNumber, string] & {
            itemType: number;
            token: string;
            identifier: BigNumber;
            amount: BigNumber;
            recipient: string;
          };
          offerer: string;
          conduitKey: string;
        })[];
      }
    >;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, BigNumber, BigNumber] & {
        isValidated: boolean;
        isCancelled: boolean;
        totalFilled: BigNumber;
        totalSize: BigNumber;
      }
    >;

    incrementCounter(overrides?: CallOverrides): Promise<BigNumber>;

    information(
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        version: string;
        domainSeparator: string;
        conduitController: string;
      }
    >;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: CallOverrides
    ): Promise<
      ([
        [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        },
        string,
        string
      ] & {
        item: [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        };
        offerer: string;
        conduitKey: string;
      })[]
    >;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: CallOverrides
    ): Promise<
      ([
        [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        },
        string,
        string
      ] & {
        item: [number, string, BigNumber, BigNumber, string] & {
          itemType: number;
          token: string;
          identifier: BigNumber;
          amount: BigNumber;
          recipient: string;
        };
        offerer: string;
        conduitKey: string;
      })[]
    >;

    name(overrides?: CallOverrides): Promise<string>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "CounterIncremented(uint256,address)"(
      newCounter?: null,
      offerer?: string | null
    ): CounterIncrementedEventFilter;
    CounterIncremented(
      newCounter?: null,
      offerer?: string | null
    ): CounterIncrementedEventFilter;

    "OrderCancelled(bytes32,address,address)"(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null
    ): OrderCancelledEventFilter;
    OrderCancelled(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null
    ): OrderCancelledEventFilter;

    "OrderFulfilled(bytes32,address,address,address,tuple[],tuple[])"(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null,
      recipient?: null,
      offer?: null,
      consideration?: null
    ): OrderFulfilledEventFilter;
    OrderFulfilled(
      orderHash?: null,
      offerer?: string | null,
      zone?: string | null,
      recipient?: null,
      offer?: null,
      consideration?: null
    ): OrderFulfilledEventFilter;

    "OrderValidated(bytes32,tuple)"(
      orderHash?: null,
      orderParameters?: null
    ): OrderValidatedEventFilter;
    OrderValidated(
      orderHash?: null,
      orderParameters?: null
    ): OrderValidatedEventFilter;

    "OrdersMatched(bytes32[])"(orderHashes?: null): OrdersMatchedEventFilter;
    OrdersMatched(orderHashes?: null): OrdersMatchedEventFilter;
  };

  estimateGas: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCounter(offerer: string, overrides?: CallOverrides): Promise<BigNumber>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    information(overrides?: CallOverrides): Promise<BigNumber>;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    cancel(
      orders: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAdvancedOrder(
      advancedOrder: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      },
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAvailableAdvancedOrders(
      advancedOrders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      recipient: string,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillAvailableOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      offerFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      considerationFulfillments: {
        orderIndex: BigNumberish;
        itemIndex: BigNumberish;
      }[][],
      fulfillerConduitKey: BytesLike,
      maximumFulfilled: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillBasicOrder(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillBasicOrder_efficient_6GL6yc(
      parameters: {
        considerationToken: string;
        considerationIdentifier: BigNumberish;
        considerationAmount: BigNumberish;
        offerer: string;
        zone: string;
        offerToken: string;
        offerIdentifier: BigNumberish;
        offerAmount: BigNumberish;
        basicOrderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        offererConduitKey: BytesLike;
        fulfillerConduitKey: BytesLike;
        totalOriginalAdditionalRecipients: BigNumberish;
        additionalRecipients: { amount: BigNumberish; recipient: string }[];
        signature: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillOrder(
      order: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      },
      fulfillerConduitKey: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getContractOffererNonce(
      contractOfferer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCounter(
      offerer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOrderHash(
      order: {
        offerer: string;
        zone: string;
        offer: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
        }[];
        consideration: {
          itemType: BigNumberish;
          token: string;
          identifierOrCriteria: BigNumberish;
          startAmount: BigNumberish;
          endAmount: BigNumberish;
          recipient: string;
        }[];
        orderType: BigNumberish;
        startTime: BigNumberish;
        endTime: BigNumberish;
        zoneHash: BytesLike;
        salt: BigNumberish;
        conduitKey: BytesLike;
        counter: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOrderStatus(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    incrementCounter(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    information(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    matchAdvancedOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        numerator: BigNumberish;
        denominator: BigNumberish;
        signature: BytesLike;
        extraData: BytesLike;
      }[],
      criteriaResolvers: {
        orderIndex: BigNumberish;
        side: BigNumberish;
        index: BigNumberish;
        identifier: BigNumberish;
        criteriaProof: BytesLike[];
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      recipient: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    matchOrders(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      fulfillments: {
        offerComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
        considerationComponents: {
          orderIndex: BigNumberish;
          itemIndex: BigNumberish;
        }[];
      }[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validate(
      orders: {
        parameters: {
          offerer: string;
          zone: string;
          offer: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
          }[];
          consideration: {
            itemType: BigNumberish;
            token: string;
            identifierOrCriteria: BigNumberish;
            startAmount: BigNumberish;
            endAmount: BigNumberish;
            recipient: string;
          }[];
          orderType: BigNumberish;
          startTime: BigNumberish;
          endTime: BigNumberish;
          zoneHash: BytesLike;
          salt: BigNumberish;
          conduitKey: BytesLike;
          totalOriginalConsiderationItems: BigNumberish;
        };
        signature: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
